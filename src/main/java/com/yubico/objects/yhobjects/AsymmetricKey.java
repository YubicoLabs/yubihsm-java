package com.yubico.objects.yhobjects;

import com.yubico.YHSession;
import com.yubico.exceptions.*;
import com.yubico.internal.util.Utils;
import com.yubico.objects.yhconcepts.Algorithm;
import com.yubico.objects.yhconcepts.Capability;
import com.yubico.objects.yhconcepts.Command;
import com.yubico.objects.yhconcepts.ObjectType;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.security.*;
import java.security.spec.*;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

public class AsymmetricKey extends YHObject {
    static Logger logger = Logger.getLogger(AsymmetricKey.class.getName());

    public static final ObjectType TYPE = ObjectType.TYPE_ASYMMETRIC_KEY;

    private final int RSA_PUBKEY_EXPONENT = 65537;

    public AsymmetricKey(YHObject key) {
        super(key.getId(), key.getType(), key.getCapabilities(), key.getObjectSize(), key.getDomains(), key.getAlgorithm(),
              key.getSequence(), key.getOrigin(), key.getLabel(), key.getDelegatedCapabilities());
    }

    /**
     * @return A list of supported asymmetric key algorithms
     */
    public static List<Algorithm> getSupportedKeyAlgorithms() {
        return Arrays.asList(Algorithm.RSA_2048, Algorithm.RSA_3072, Algorithm.RSA_4096, Algorithm.EC_P224, Algorithm.EC_P256, Algorithm.EC_P384,
                             Algorithm.EC_P521, Algorithm.EC_K256, Algorithm.EC_BP256, Algorithm.EC_BP384, Algorithm.EC_BP512,
                             Algorithm.EC_ED25519);
    }

    /**
     * @return A list of supported signing algorithms
     */
    public static List<Algorithm> getSupportedSigningAlgorithms() {
        return Arrays.asList(Algorithm.RSA_PKCS1_SHA1, Algorithm.RSA_PKCS1_SHA256, Algorithm.RSA_PKCS1_SHA384, Algorithm.RSA_PKCS1_SHA512,
                             Algorithm.RSA_PSS_SHA1, Algorithm.RSA_PSS_SHA256,
                             Algorithm.RSA_PSS_SHA384, Algorithm.RSA_PSS_SHA512, Algorithm.EC_ECDSA_SHA1, Algorithm.EC_ECDSA_SHA256,
                             Algorithm.EC_ECDSA_SHA384, Algorithm.EC_ECDSA_SHA512);

    }

    /**
     * @return A list of supported decryption algorithms
     */
    public static List<Algorithm> getSupportedDecryptionAlgorithms() {
        return getSupportedSigningAlgorithms();
    }

    // -----------------------------------------------------------------------------------------------
    //                                          Key Generation
    // ------------------------------------------------------------------------------------------------

    /**
     * Generates an asymmetric key on the YubiHSM
     *
     * @param session      An authenticated session to communicate with the device over
     * @param id           The ID of the Asymmetric Key. 0 if the ID is to be generated by the device
     * @param label        The Asymmetric Key label
     * @param domains      The domains where the Asymmetric Key will be operating within
     * @param capabilities The capabilities of the Asymmetric Key
     * @param algorithm    The algorithm used to generate the asymmetric key
     * @return ID of the Asymmetric Key generated on the device
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     */
    public static short generateAsymmetricKey(final YHSession session, short id, String label, final List<Integer> domains,
                                              final List<Capability> capabilities, final Algorithm algorithm)
            throws NoSuchAlgorithmException, YHDeviceException, YHInvalidResponseException, YHConnectionException, InvalidKeyException,
                   YHAuthenticationException, NoSuchPaddingException, InvalidAlgorithmParameterException, BadPaddingException,
                   IllegalBlockSizeException {
        checkNullParameters(session, domains, capabilities, algorithm);

        ByteBuffer bb = ByteBuffer.allocate(53);
        bb.putShort(id);
        bb.put(Arrays.copyOf(getLabel(label).getBytes(), LABEL_LENGTH));
        bb.putShort(Utils.getShortFromList(domains));
        bb.putLong(Capability.getCapabilities(capabilities));
        bb.put(algorithm.getAlgorithmId());

        byte[] resp = session.sendSecureCmd(Command.GENERATE_ASYMMETRIC_KEY, bb.array());
        bb = ByteBuffer.wrap(resp);
        id = bb.getShort();

        logger.info("Generated asymmetric key with ID 0x" + Integer.toHexString(id));
        return id;
    }

    // -----------------------------------------------------------------------------------------------
    //                                          Key Import
    // ------------------------------------------------------------------------------------------------

    /**
     * Imports a user generated RSA key into the YubiHSM
     *
     * @param session      An authenticated session to communicate with the device over
     * @param id           The ID of the Asymmetric Key. 0 if the ID is to be generated by the device
     * @param label        The Asymmetric Key label
     * @param domains      The domains where the Asymmetric Key will be operating within
     * @param capabilities The capabilities of the Asymmetric Key
     * @param algorithm    The algorithm used to generate the asymmetric key
     * @param primeP       The secret prime P. For ECC, the private key integer d. For EDC, the private key integer k.
     * @param primeQ       The secret prime Q. For ECC and EDC, not applicable and recommend to set to 'null'
     * @return ID of the RSA key on the device
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     */
    public static short importRsaKey(final YHSession session, short id, String label, final List<Integer> domains,
                                     final List<Capability> capabilities, final Algorithm algorithm, final byte[] primeP, final byte[] primeQ)
            throws NoSuchAlgorithmException, YHDeviceException, YHInvalidResponseException, YHConnectionException, InvalidKeyException,
                   YHAuthenticationException, NoSuchPaddingException, InvalidAlgorithmParameterException, BadPaddingException,
                   IllegalBlockSizeException {
        checkNullParameters(session, domains, capabilities, algorithm);
        Utils.checkNullValue(primeP, "Missing prime P");
        Utils.checkNullValue(primeQ, "Missing prime Q");
        if (!algorithm.isRsaAlgorithm()) {
            throw new InvalidParameterException("Specified algorithm is not a supported RSA algorithm");
        }

        final int componentLength = getRsaComponentLength(algorithm);
        if (primeP.length != componentLength || primeQ.length != componentLength) {
            throw new InvalidParameterException("Invalid parameter: primeP, primeQ");
        }

        return putKey(session, id, getLabel(label), domains, capabilities, algorithm, primeP, primeQ);
    }

    /**
     * Imports a user generated EC key into the YubiHSM
     *
     * @param session      An authenticated session to communicate with the device over
     * @param id           The ID of the Asymmetric Key. 0 if the ID is to be generated by the device
     * @param label        The Asymmetric Key label
     * @param domains      The domains where the Asymmetric Key will be operating within
     * @param capabilities The capabilities of the Asymmetric Key
     * @param algorithm    The algorithm used to generate the asymmetric key
     * @param d            The private key integer d
     * @return ID of the EC key on the device
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     */
    public static short importEcKey(final YHSession session, short id, final String label, final List<Integer> domains,
                                    final List<Capability> capabilities, final Algorithm algorithm, final byte[] d)
            throws NoSuchAlgorithmException, YHDeviceException, YHInvalidResponseException, YHConnectionException, InvalidKeyException,
                   YHAuthenticationException, NoSuchPaddingException, InvalidAlgorithmParameterException, BadPaddingException,
                   IllegalBlockSizeException {
        Utils.checkNullValue(d, "Missing parameter d");
        if (d.length != getEcComponentLength(algorithm)) {
            throw new InvalidParameterException("Invalid parameter: d");
        }

        if (!algorithm.isEcAlgorithm()) {
            throw new InvalidParameterException("Specified algorithm is not a supported EC algorithm");
        }

        return putKey(session, id, getLabel(label), domains, capabilities, algorithm, d, null);
    }

    /**
     * Imports a user generated ED key into the YubiHSM
     *
     * @param session      An authenticated session to communicate with the device over
     * @param id           The ID of the Asymmetric Key. 0 if the ID is to be generated by the device
     * @param label        The Asymmetric Key label
     * @param domains      The domains where the Asymmetric Key will be operating within
     * @param capabilities The capabilities of the Asymmetric Key
     * @param algorithm    The algorithm used to generate the asymmetric key
     * @param k            The private key integer k.
     * @return ID of the ED key on the device
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     */
    public static short importEdKey(final YHSession session, short id, final String label, final List<Integer> domains,
                                    final List<Capability> capabilities, final Algorithm algorithm, final byte[] k)
            throws NoSuchAlgorithmException, YHDeviceException, YHInvalidResponseException, YHConnectionException, InvalidKeyException,
                   YHAuthenticationException, NoSuchPaddingException, InvalidAlgorithmParameterException, BadPaddingException,
                   IllegalBlockSizeException {
        checkNullParameters(session, domains, capabilities, algorithm);
        Utils.checkNullValue(k, "Missing parameter: k");

        if (!algorithm.isEdAlgorithm()) {
            throw new InvalidParameterException("Specified algorithm is not a supported ED algorithm");
        }

        if (k.length != 32) {
            throw new InvalidParameterException("Invalid parameter: k");
        }
        return putKey(session, id, label, domains, capabilities, algorithm, k, null);
    }

    private static void checkNullParameters(final YHSession session, final List<Integer> domains, final List<Capability> capabilities,
                                            final Algorithm algorithm) {
        Utils.checkNullValue(session, "Session is null. Creating a new authentication key must be done over an authenticated session");
        Utils.checkNullValue(domains, "Missing domains parameter. Authentication Key must be able to operate within at least one domain");
        Utils.checkNullValue(capabilities, "Missing capabilities");
        Utils.checkNullValue(algorithm, "Missing key algorithm");
    }

    // Returns how long the p and q primes are expected to be given the algorithm
    private static int getRsaComponentLength(final Algorithm algorithm) {
        if (algorithm.equals(Algorithm.RSA_2048)) {
            return 128;
        } else if (algorithm.equals(Algorithm.RSA_3072)) {
            return 192;
        } else if (algorithm.equals(Algorithm.RSA_4096)) {
            return 256;
        } else {
            throw new InvalidParameterException("Unsupported RSA Algorithm: " + algorithm.toString());
        }
    }

    // Returns how long the d private integer is expected to be given the algorithm
    private static int getEcComponentLength(final Algorithm algorithm) {
        if (algorithm.equals(Algorithm.EC_P224)) {
            return 28;
        } else if (algorithm.equals(Algorithm.EC_P256) || algorithm.equals(Algorithm.EC_K256) || algorithm.equals(Algorithm.EC_BP256)) {
            return 32;
        } else if (algorithm.equals(Algorithm.EC_P384) || algorithm.equals(Algorithm.EC_BP384)) {
            return 48;
        } else if (algorithm.equals(Algorithm.EC_BP512)) {
            return 64;
        } else if (algorithm.equals(Algorithm.EC_P521)) {
            return 66;
        } else {
            throw new InvalidParameterException("Unsupported EC algorithm: " + algorithm.toString());
        }
    }

    private static String getLabel(String label) {
        if (label == null) {
            return "";
        }
        if (label.length() > LABEL_LENGTH) {
            throw new InvalidParameterException("Invalid parameter: label");
        }
        return label;
    }

    private static short putKey(final YHSession session, short id, final String label, final List<Integer> domains,
                                final List<Capability> capabilities, final Algorithm algorithm, final byte[] p1, final byte[] p2)
            throws NoSuchAlgorithmException, YHDeviceException, YHInvalidResponseException, YHConnectionException, InvalidKeyException,
                   YHAuthenticationException, NoSuchPaddingException, InvalidAlgorithmParameterException, BadPaddingException,
                   IllegalBlockSizeException {

        int length = 53 + p1.length; // 2 + 40 + 2 + 8 + 1 + p1 length
        if (p2 != null) {
            length += p2.length;
        }

        ByteBuffer bb = ByteBuffer.allocate(length);
        bb.putShort(id);
        bb.put(Arrays.copyOf(label.getBytes(), LABEL_LENGTH));
        bb.putShort(Utils.getShortFromList(domains));
        bb.putLong(Capability.getCapabilities(capabilities));
        bb.put(algorithm.getAlgorithmId());
        bb.put(p1);
        if (p2 != null) {
            bb.put(p2);
        }

        byte[] resp = session.sendSecureCmd(Command.PUT_ASYMMETRIC_KEY, bb.array());
        bb = ByteBuffer.wrap(resp);
        id = bb.getShort();

        logger.info("Imported asymmetric key with ID 0x" + Integer.toHexString(id) + " and algorithm " + algorithm.toString());
        return id;
    }

    // -----------------------------------------------------------------------------------------------
    //                                          Public Key
    // ------------------------------------------------------------------------------------------------

    private Map<Algorithm, String> algorithmToCurveMap = new HashMap<Algorithm, String>() {{
        put(Algorithm.EC_P224, "secp224r1");
        put(Algorithm.EC_P256, "secp256r1");
        put(Algorithm.EC_P384, "secp384r1");
        put(Algorithm.EC_P521, "secp521r1");
        put(Algorithm.EC_K256, "secp256k1");
        put(Algorithm.EC_BP256, "brainpoolP256r1");
        put(Algorithm.EC_BP384, "brainpoolP384r1");
        put(Algorithm.EC_BP512, "brainpoolP512r1");
    }};


    /**
     * Returns the public
     *
     * @param session An authenticated session to communicate with the device over
     * @return The public part of this asymmetric key. In case of RSA key or EC key, the returned object is of type java.security.PublicKey. In
     * case of an ED key, the returned object is a byte array
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     * @throws InvalidKeySpecException            If failed to construct the public key object
     * @throws InvalidParameterSpecException      If failed to construct the public key object
     * @throws UnsupportedAlgorithmException      If the asymmetric key algorithm is not recognized
     */
    public Object getPublicKey(final YHSession session)
            throws NoSuchPaddingException, NoSuchAlgorithmException, YHConnectionException, InvalidKeyException, YHDeviceException,
                   InvalidAlgorithmParameterException, YHAuthenticationException, YHInvalidResponseException, BadPaddingException,
                   IllegalBlockSizeException, InvalidKeySpecException, InvalidParameterSpecException, UnsupportedAlgorithmException,
                   NoSuchProviderException {
        ByteBuffer bb = ByteBuffer.allocate(2);
        bb.putShort(getId());

        byte[] resp = session.sendSecureCmd(Command.GET_PUBLIC_KEY, bb.array());
        bb = ByteBuffer.wrap(resp);
        final Algorithm algorithm = Algorithm.getAlgorithm(bb.get());
        if (!algorithm.equals(getAlgorithm())) {
            throw new YHInvalidResponseException("The public key algorithm returned by the device does not match the private key algorithm");
        }

        if (algorithm.isRsaAlgorithm()) {
            byte[] mod = new byte[bb.remaining()];
            bb.get(mod);

            byte[] expo = BigInteger.valueOf(RSA_PUBKEY_EXPONENT).toByteArray();

            // There has been a change in Java from 1.8.0_161 (referenced by JDK-8174756):
            // "RSA public key validation In 8u161, the RSA implementation in the SunRsaSign provider will reject any RSA public key that has an
            // exponent that is not in the valid range as defined by PKCS#1 version 2.2. This change will affect JSSE connections as well as
            // applications built on JCE."
            // This basically means that modulus shouldn't be negative. Which is why it is necessary to specifically set the signum value to 1 (to
            // get a positive BigInteger value)
            RSAPublicKeySpec spec = new RSAPublicKeySpec(new BigInteger(1, mod), new BigInteger(1, expo));
            KeyFactory factory = KeyFactory.getInstance("RSA");
            logger.info("Returned public RSA key with ID 0x" + Integer.toHexString(getId()));
            return factory.generatePublic(spec);
        }

        if (algorithm.isEcAlgorithm()) {
            byte[] x = new byte[bb.remaining() / 2];
            bb.get(x);
            byte[] y = new byte[bb.remaining()];
            bb.get(y);

            ECPoint pubPoint = new ECPoint(new BigInteger(1, x), new BigInteger(1, y));
            if (algorithm.equals(Algorithm.EC_BP256) || algorithm.equals(Algorithm.EC_BP384) || algorithm.equals(Algorithm.EC_BP512)) {
                return getEcBrainpoolPublicKey(pubPoint, algorithm);
            } else {
                return getEcPublicKey(pubPoint, algorithm);
            }
        }

        if (algorithm.isEdAlgorithm()) {
            byte[] pubkey = new byte[bb.remaining()];
            bb.get(pubkey);
            logger.info("Returned public EC key with ID 0x" + Integer.toHexString(getId()));
            return pubkey;
        }

        throw new UnsupportedAlgorithmException();
    }

    private PublicKey getEcPublicKey(final ECPoint point, final Algorithm algorithm)
            throws NoSuchAlgorithmException, InvalidParameterSpecException, InvalidKeySpecException {
        AlgorithmParameters parameters = AlgorithmParameters.getInstance("EC");
        parameters.init(new ECGenParameterSpec(algorithmToCurveMap.get(algorithm)));
        ECParameterSpec ecParameters = parameters.getParameterSpec(ECParameterSpec.class);
        ECPublicKeySpec pubSpec = new ECPublicKeySpec(point, ecParameters);
        KeyFactory kf = KeyFactory.getInstance("EC");
        logger.info("Returned public EC key with ID 0x" + Integer.toHexString(getId()));
        return kf.generatePublic(pubSpec);
    }

    private PublicKey getEcBrainpoolPublicKey(final ECPoint point, final Algorithm algorithm)
            throws NoSuchAlgorithmException, NoSuchProviderException, InvalidParameterSpecException, InvalidKeySpecException {
        Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());
        AlgorithmParameters parameters = AlgorithmParameters.getInstance("EC", "BC");
        parameters.init(new ECGenParameterSpec(algorithmToCurveMap.get(algorithm)));
        ECParameterSpec ecParameters = parameters.getParameterSpec(ECParameterSpec.class);
        ECPublicKeySpec pubSpec = new ECPublicKeySpec(point, ecParameters);
        KeyFactory kf = KeyFactory.getInstance("EC", "BC");
        logger.info("Returned public EC key with ID 0x" + Integer.toHexString(getId()));
        return kf.generatePublic(pubSpec);
    }

    // --------------------------------------------------------------------------------
    //                                 Signing
    // --------------------------------------------------------------------------------

    /**
     * Signs the hash of the input data using RSA-PKCS#1v1.5.
     *
     * @param session       An authenticated session to communicate with the device over
     * @param data          The raw data to sign
     * @param hashAlgorithm The digest algorithm used to hash the data before signing it. Can be one of
     *                      {{@link Algorithm.RSA_PKCS1_SHA1}}, {{@link Algorithm.RSA_PKCS1_SHA256}}, {{@link Algorithm.RSA_PKCS1_SHA384}},
     *                      {{@link Algorithm.RSA_PKCS1_SHA512}}
     * @return The signature
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     */
    public byte[] signPkcs1(final YHSession session, final byte[] data, final Algorithm hashAlgorithm)
            throws NoSuchPaddingException, NoSuchAlgorithmException, YHConnectionException, InvalidKeyException, YHDeviceException,
                   InvalidAlgorithmParameterException, YHAuthenticationException, YHInvalidResponseException, BadPaddingException,
                   IllegalBlockSizeException {
        if (!getAlgorithm().isRsaAlgorithm()) {
            throw new UnsupportedOperationException("This operation is only available for RSA keys");
        }

        final byte[] hashedData = getHashedData(data, hashAlgorithm);
        return signPkcs1(session, hashedData);
    }

    /**
     * Signs the input data using RSA-PKCS#1v1.5. The input data is expected to be a hash of the raw data
     *
     * @param session    An authenticated session to communicate with the device over
     * @param dataDigest The hash of the data to sign
     * @return The signature
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     */
    public byte[] signPkcs1(final YHSession session, final byte[] dataDigest)
            throws NoSuchPaddingException, NoSuchAlgorithmException, YHConnectionException, InvalidKeyException, YHDeviceException,
                   InvalidAlgorithmParameterException, YHAuthenticationException, YHInvalidResponseException, BadPaddingException,
                   IllegalBlockSizeException {
        if (!getAlgorithm().isRsaAlgorithm()) {
            throw new UnsupportedOperationException("This operation is only available for RSA keys");
        }

        ByteBuffer bb = ByteBuffer.allocate(2 + dataDigest.length);
        bb.putShort(getId());
        bb.put(dataDigest);

        byte[] signature = session.sendSecureCmd(Command.SIGN_PKCS1, bb.array());
        logger.info("Signed data with key 0x" + Integer.toHexString(getId()));
        return signature;
    }

    /**
     * Signs the input data using RSA-PSS as defined in RFC 3447
     *
     * @param session       An authenticated session to communicate with the device over
     * @param mgf1Algorithm The MGF1 algorithm used for signing. Can be one of {{@link Algorithm.RSA_MGF1_SHA1}}, {{@link Algorithm.RSA_MGF1_SHA256}},
     *                      {{@link Algorithm.RSA_MGF1_SHA384}},{{@link Algorithm.RSA_MGF1_SHA512}}
     * @param saltLength    Length of salt
     * @param data          The raw data to be signed
     * @return The signature
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     */
    public byte[] signPss(final YHSession session, final Algorithm mgf1Algorithm, final short saltLength, byte[] data)
            throws NoSuchPaddingException, NoSuchAlgorithmException, YHConnectionException, InvalidKeyException, YHDeviceException,
                   InvalidAlgorithmParameterException, YHAuthenticationException, YHInvalidResponseException, BadPaddingException,
                   IllegalBlockSizeException {
        if (!getAlgorithm().isRsaAlgorithm()) {
            throw new UnsupportedOperationException("This operation is only available for RSA keys");
        }

        if (!mgf1Algorithm.equals(Algorithm.RSA_MGF1_SHA1) && !mgf1Algorithm.equals(Algorithm.RSA_MGF1_SHA256) &&
            !mgf1Algorithm.equals(Algorithm.RSA_MGF1_SHA384) && !mgf1Algorithm.equals(Algorithm.RSA_MGF1_SHA512)) {
            throw new InvalidParameterException("Unsupported hash algorithm to use for MGF1");
        }

        final byte[] hashedData = getHashedData(data, mgf1Algorithm);

        if (hashedData.length != getPssHashLength(mgf1Algorithm)) {
            throw new InvalidParameterException("Length of hashed data must be 20, 32, 48 or 64");
        }

        ByteBuffer bb = ByteBuffer.allocate(5 + hashedData.length); // 2 + 1 + 2 + datalength
        bb.putShort(getId());
        bb.put(mgf1Algorithm.getAlgorithmId());
        bb.putShort(saltLength);
        bb.put(hashedData);

        byte[] signature = session.sendSecureCmd(Command.SIGN_PSS, bb.array());
        logger.info("Signed data with key 0x" + Integer.toHexString(getId()));
        return signature;
    }

    /**
     * Signs the input data using ECDSA
     *
     * @param session       An authenticated session to communicate with the device over
     * @param data          The raw data to sign
     * @param hashAlgorithm The digest algorithm used to hash the data before signing it. Can be one of
     *                      {{@link Algorithm.EC_ECDSA_SHA1}}, {{@link Algorithm.EC_ECDSA_SHA256}}, {{@link Algorithm.EC_ECDSA_SHA384}},
     *                      {{@link Algorithm.EC_ECDSA_SHA512}}
     * @return The signature
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     */
    public byte[] signEcdsa(final YHSession session, final byte[] data, final Algorithm hashAlgorithm)
            throws NoSuchPaddingException, NoSuchAlgorithmException, YHConnectionException, InvalidKeyException, YHDeviceException,
                   InvalidAlgorithmParameterException, YHAuthenticationException, YHInvalidResponseException, BadPaddingException,
                   IllegalBlockSizeException {
        if (!getAlgorithm().isEcAlgorithm()) {
            throw new UnsupportedOperationException("This operation is only available for EC keys");
        }

        final byte[] hashedData = getHashedData(data, hashAlgorithm);
        return signEcdsa(session, hashedData);
    }

    /**
     * Signs the input data using ECDSA. The input data is expected to be a hash of the raw data
     *
     * @param session    An authenticated session to communicate with the device over
     * @param dataDigest The hash of the data to sign
     * @return The signature
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     */
    public byte[] signEcdsa(final YHSession session, final byte[] dataDigest)
            throws NoSuchPaddingException, NoSuchAlgorithmException, YHConnectionException, InvalidKeyException, YHDeviceException,
                   InvalidAlgorithmParameterException, YHAuthenticationException, YHInvalidResponseException, BadPaddingException,
                   IllegalBlockSizeException {
        if (!getAlgorithm().isEcAlgorithm()) {
            throw new UnsupportedOperationException("This operation is only available for EC keys");
        }

        ByteBuffer bb = ByteBuffer.allocate(2 + dataDigest.length);
        bb.putShort(getId());
        bb.put(dataDigest);

        byte[] signature = session.sendSecureCmd(Command.SIGN_ECDSA, bb.array());
        logger.info("Signed data with key 0x" + Integer.toHexString(getId()));
        return signature;
    }

    /**
     * Signs the input data using EdDSA. Currently, only Ed25519 is supported
     *
     * @param session An authenticated session to communicate with the device over
     * @param data    The raw data to sign
     * @return The signature, 64 bytes
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     */
    public byte[] signEddsa(final YHSession session, final byte[] data)
            throws NoSuchPaddingException, NoSuchAlgorithmException, YHConnectionException, InvalidKeyException, YHDeviceException,
                   InvalidAlgorithmParameterException, YHAuthenticationException, YHInvalidResponseException, BadPaddingException,
                   IllegalBlockSizeException {
        if (!getAlgorithm().isEdAlgorithm()) {
            throw new UnsupportedOperationException("This operation is only available for ED keys");
        }

        ByteBuffer bb = ByteBuffer.allocate(2 + data.length);
        bb.putShort(getId());
        bb.put(data);

        byte[] signature = session.sendSecureCmd(Command.SIGN_EDDSA, bb.array());
        logger.info("Signed data with key 0x" + Integer.toHexString(getId()));
        return signature;
    }


    private int getPssHashLength(final Algorithm algorithm) {
        if (algorithm.equals(Algorithm.RSA_MGF1_SHA1)) {
            return 20;
        }
        if (algorithm.equals(Algorithm.RSA_MGF1_SHA256)) {
            return 32;
        }
        if (algorithm.equals(Algorithm.RSA_MGF1_SHA384)) {
            return 48;
        }
        if (algorithm.equals(Algorithm.RSA_MGF1_SHA512)) {
            return 64;
        }
        throw new InvalidParameterException("Unsupported hash algorithm to use for MGF1");
    }

    private byte[] getHashedData(final byte[] data, final Algorithm algorithm) throws NoSuchAlgorithmException {
        MessageDigest digest;
        if (algorithm == null) {
            return data;
        } else if (algorithm.equals(Algorithm.RSA_PKCS1_SHA1) || algorithm.equals(Algorithm.RSA_MGF1_SHA1) ||
                   algorithm.equals(Algorithm.EC_ECDSA_SHA1)) {
            digest = MessageDigest.getInstance("SHA-1");
        } else if (algorithm.equals(Algorithm.RSA_PKCS1_SHA256) || algorithm.equals(Algorithm.RSA_MGF1_SHA256) ||
                   algorithm.equals(Algorithm.EC_ECDSA_SHA256)) {
            digest = MessageDigest.getInstance("SHA-256");
        } else if (algorithm.equals(Algorithm.RSA_PKCS1_SHA384) || algorithm.equals(Algorithm.RSA_MGF1_SHA384) ||
                   algorithm.equals(Algorithm.EC_ECDSA_SHA384)) {
            digest = MessageDigest.getInstance("SHA-384");
        } else if (algorithm.equals(Algorithm.RSA_PKCS1_SHA512) || algorithm.equals(Algorithm.RSA_MGF1_SHA512) ||
                   algorithm.equals(Algorithm.EC_ECDSA_SHA512)) {
            digest = MessageDigest.getInstance("SHA-512");
        } else {
            throw new InvalidParameterException("Unsupported hash algorithm " + algorithm.toString());
        }
        return digest.digest(data);
    }

}
