package com.yubico.objects.yhobjects;


import com.yubico.YHSession;
import com.yubico.exceptions.*;
import com.yubico.internal.util.Utils;
import com.yubico.objects.yhconcepts.Algorithm;
import com.yubico.objects.yhconcepts.Capability;
import com.yubico.objects.yhconcepts.Command;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.RSAPublicKeySpec;
import java.util.List;

public class AsymmetricKeyRsa extends AsymmetricKey {

    private final int RSA_PUBKEY_EXPONENT = 65537;

    private AsymmetricKeyRsa(final YHObject key) {
        super(key);
    }

    /**
     * Returns an instance of this RSA Key
     *
     * @param key The key properties
     * @return An instance of the RSA Key
     * @throws UnsupportedAlgorithmException If the algorithm specified in the properties is not an RSA key algorithm
     */
    public static AsymmetricKeyRsa getInstance(final YHObject key) throws UnsupportedAlgorithmException {
        if (key.getAlgorithm() != null && key.getAlgorithm().isRsaAlgorithm()) {
            return new AsymmetricKeyRsa(key);
        }
        throw new UnsupportedAlgorithmException("The object is not an RSA key");
    }

    /**
     * Imports a user generated RSA key into the YubiHSM
     *
     * @param session      An authenticated session to communicate with the device over
     * @param id           The ID of the Asymmetric Key. 0 if the ID is to be generated by the device
     * @param label        The Asymmetric Key label
     * @param domains      The domains where the Asymmetric Key will be operating within
     * @param capabilities The capabilities of the Asymmetric Key
     * @param algorithm    The algorithm used to generate the asymmetric key
     * @param primeP       The secret prime P. For ECC, the private key integer d. For EDC, the private key integer k.
     * @param primeQ       The secret prime Q. For ECC and EDC, not applicable and recommend to set to 'null'
     * @return ID of the RSA key on the device
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     * @throws UnsupportedAlgorithmException      If the specified key algorithm is not an RSA algorithm
     */
    public static short importKey(final YHSession session, short id, String label, final List<Integer> domains, final List<Capability> capabilities
            , final Algorithm algorithm, final byte[] primeP, final byte[] primeQ)
            throws NoSuchAlgorithmException, YHDeviceException, YHInvalidResponseException, YHConnectionException, InvalidKeyException,
                   YHAuthenticationException, NoSuchPaddingException, InvalidAlgorithmParameterException, BadPaddingException,
                   IllegalBlockSizeException, UnsupportedAlgorithmException {
        checkNullParameters(session, domains, capabilities, algorithm);
        Utils.checkEmptyByteArray(primeP, "Missing prime P");
        Utils.checkEmptyByteArray(primeQ, "Missing prime Q");
        if (!algorithm.isRsaAlgorithm()) {
            throw new UnsupportedAlgorithmException("Specified algorithm is not a supported RSA algorithm");
        }

        final int componentLength = getBlockSize(algorithm) / 2;
        if (primeP.length != componentLength || primeQ.length != componentLength) {
            throw new InvalidParameterException("Invalid parameter: primeP, primeQ");
        }

        return putKey(session, id, getLabel(label), domains, capabilities, algorithm, primeP, primeQ);
    }

    /**
     * Returns the public component of this RSA key.
     * <p>
     * The RSA public key exponent is 0x10001
     *
     * @param session An authenticated session to communicate with the device over
     * @return The public component of this RSA key as a java.security.PublicKey object
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     * @throws InvalidKeySpecException            If failed to construct the public key object
     */
    @Override
    public Object getPublicKey(final YHSession session)
            throws NoSuchPaddingException, NoSuchAlgorithmException, YHConnectionException, InvalidKeyException, YHDeviceException,
                   InvalidAlgorithmParameterException, YHAuthenticationException, YHInvalidResponseException, BadPaddingException,
                   IllegalBlockSizeException, InvalidKeySpecException {
        ByteBuffer bb = ByteBuffer.allocate(2);
        bb.putShort(getId());

        byte[] resp = session.sendSecureCmd(Command.GET_PUBLIC_KEY, bb.array());
        bb = ByteBuffer.wrap(resp);
        final Algorithm algorithm = Algorithm.getAlgorithm(bb.get());
        if (algorithm==null || !algorithm.equals(getAlgorithm())) {
            throw new YHInvalidResponseException("The public key algorithm returned by the device does not match the private key algorithm");
        }

        byte[] mod = new byte[bb.remaining()];
        bb.get(mod);

        byte[] expo = BigInteger.valueOf(RSA_PUBKEY_EXPONENT).toByteArray();

        // There has been a change in Java from 1.8.0_161 (referenced by JDK-8174756):
        // "RSA public key validation In 8u161, the RSA implementation in the SunRsaSign provider will reject any RSA public key that has an
        // exponent that is not in the valid range as defined by PKCS#1 version 2.2. This change will affect JSSE connections as well as
        // applications built on JCE."
        // This basically means that modulus shouldn't be negative. Which is why it is necessary to specifically set the signum value to 1 (to
        // get a positive BigInteger value)
        RSAPublicKeySpec spec = new RSAPublicKeySpec(new BigInteger(1, mod), new BigInteger(1, expo));
        KeyFactory factory = KeyFactory.getInstance("RSA");
        logger.info("Returned public RSA key with ID 0x" + Integer.toHexString(getId()));
        return factory.generatePublic(spec);
    }

    /**
     * Signs the hash of the input data using RSA-PKCS#1v1.5.
     *
     * @param session       An authenticated session to communicate with the device over
     * @param data          The raw data to sign
     * @param hashAlgorithm The digest algorithm used to hash the data before signing it. Can be one of
     *                      {{@link Algorithm.RSA_PKCS1_SHA1}}, {{@link Algorithm.RSA_PKCS1_SHA256}}, {{@link Algorithm.RSA_PKCS1_SHA384}},
     *                      {{@link Algorithm.RSA_PKCS1_SHA512}}
     * @return The signature
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     * @throws UnsupportedAlgorithmException      If the hash Algorithm is not one of {{@link Algorithm.RSA_PKCS1_SHA1}}, {
     *                                            {@link Algorithm.RSA_PKCS1_SHA256}}, {{@link Algorithm.RSA_PKCS1_SHA384}}, {{@link Algorithm.RSA_PKCS1_SHA512}}
     */
    public byte[] signPkcs1(final YHSession session, final byte[] data, final Algorithm hashAlgorithm)
            throws NoSuchPaddingException, NoSuchAlgorithmException, YHConnectionException, InvalidKeyException, YHDeviceException,
                   InvalidAlgorithmParameterException, YHAuthenticationException, YHInvalidResponseException, BadPaddingException,
                   IllegalBlockSizeException, UnsupportedAlgorithmException {
        if (!getAlgorithm().isRsaAlgorithm()) {
            throw new UnsupportedOperationException("This operation is only available for RSA keys");
        }
        if (!isPkcs1HashAlgorithm(hashAlgorithm)) {
            throw new UnsupportedAlgorithmException(hashAlgorithm.toString());
        }

        final byte[] hashedData = getHashedData(data, hashAlgorithm);
        return signPkcs1(session, hashedData);
    }

    /**
     * Signs the input data using RSA-PKCS#1v1.5. The input data is expected to be a hash of the raw data
     *
     * @param session    An authenticated session to communicate with the device over
     * @param dataDigest The hash of the data to sign
     * @return The signature
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     */
    public byte[] signPkcs1(final YHSession session, final byte[] dataDigest)
            throws NoSuchPaddingException, NoSuchAlgorithmException, YHConnectionException, InvalidKeyException, YHDeviceException,
                   InvalidAlgorithmParameterException, YHAuthenticationException, YHInvalidResponseException, BadPaddingException,
                   IllegalBlockSizeException {
        if (!getAlgorithm().isRsaAlgorithm()) {
            throw new UnsupportedOperationException("This operation is only available for RSA keys");
        }

        ByteBuffer bb = ByteBuffer.allocate(2 + dataDigest.length);
        bb.putShort(getId());
        bb.put(dataDigest);

        byte[] signature = session.sendSecureCmd(Command.SIGN_PKCS1, bb.array());
        logger.info("Signed data with key 0x" + Integer.toHexString(getId()) + " and returned " + signature.length + " bytes signature");
        return signature;
    }

    /**
     * Signs the input data using RSA-PSS as defined in RFC 3447
     *
     * @param session       An authenticated session to communicate with the device over
     * @param mgf1Algorithm The MGF1 algorithm used for signing. Can be one of {{@link Algorithm.RSA_MGF1_SHA1}}, {{@link Algorithm.RSA_MGF1_SHA256}},
     *                      {{@link Algorithm.RSA_MGF1_SHA384}},{{@link Algorithm.RSA_MGF1_SHA512}}
     * @param saltLength    Length of salt
     * @param data          The raw data to be signed
     * @return The signature
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     * @throws UnsupportedAlgorithmException      If the hash Algorithm is not one of {{@link Algorithm.RSA_MGF1_SHA1}}, {
     *                                            * {@link Algorithm.RSA_MGF1_SHA256}}, {{@link Algorithm.RSA_MGF1_SHA384}}, {{@link Algorithm.RSA_MGF1_SHA512}}
     */
    public byte[] signPss(final YHSession session, final Algorithm mgf1Algorithm, final short saltLength, byte[] data)
            throws NoSuchPaddingException, NoSuchAlgorithmException, YHConnectionException, InvalidKeyException, YHDeviceException,
                   InvalidAlgorithmParameterException, YHAuthenticationException, YHInvalidResponseException, BadPaddingException,
                   IllegalBlockSizeException, UnsupportedAlgorithmException {
        if (!getAlgorithm().isRsaAlgorithm()) {
            throw new UnsupportedOperationException("This operation is only available for RSA keys");
        }

        if (!isMgf1Algorithm(mgf1Algorithm)) {
            throw new UnsupportedAlgorithmException("Unsupported hash algorithm to use for MGF1");
        }

        final byte[] hashedData = getHashedData(data, mgf1Algorithm);

        if (hashedData.length != getHashLength(mgf1Algorithm)) {
            throw new InvalidParameterException("Length of hashed data must be 20, 32, 48 or 64");
        }

        ByteBuffer bb = ByteBuffer.allocate(5 + hashedData.length); // 2 + 1 + 2 + datalength
        bb.putShort(getId());
        bb.put(mgf1Algorithm.getAlgorithmId());
        bb.putShort(saltLength);
        bb.put(hashedData);

        byte[] signature = session.sendSecureCmd(Command.SIGN_PSS, bb.array());
        logger.info("Signed data with key 0x" + Integer.toHexString(getId()) + " and returned " + signature.length + " bytes signature");
        return signature;
    }

    /**
     * Decrypt data that was encrypted using RSA-PKCS#1v1.5. Length of the data has to be 256, 384 or 512 bytes
     * <p>
     * The data is padded using the PKCS#1v1.5 scheme with Block Type 2. The data is decrypted and conformance to the padding scheme is checked
     * then removed before returning the contained message
     *
     * @param session An authenticated session to communicate with the device over
     * @param enc     Data encrypted using RSA-PKCS#1v1.5
     * @return The decrypted data
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     */
    public byte[] decryptPkcs1(final YHSession session, byte[] enc)
            throws NoSuchPaddingException, NoSuchAlgorithmException, YHConnectionException, InvalidKeyException, YHDeviceException,
                   InvalidAlgorithmParameterException, YHAuthenticationException, YHInvalidResponseException, BadPaddingException,
                   IllegalBlockSizeException {
        if (!getAlgorithm().isRsaAlgorithm()) {
            throw new UnsupportedOperationException("This operation is only available for RSA keys");
        }
        if (enc == null) {
            return new byte[0];
        }
        if (enc.length != getBlockSize(getAlgorithm())) {
            throw new InvalidParameterException("Length of encrypted data must be 256, 384 or 512");
        }

        ByteBuffer bb = ByteBuffer.allocate(2 + enc.length);
        bb.putShort(getId());
        bb.put(enc);

        byte[] dec = session.sendSecureCmd(Command.DECRYPT_PKCS1, bb.array());
        logger.info("Decrypted data with key 0x" + Integer.toHexString(getId()) + " and returned " + dec.length + " bytes");
        return dec;
    }

    /**
     * Decrypt data using RSA-OAEP. Length of the data has to be 256, 384 or 512 bytes
     *
     * @param session       An authenticated session to communicate with the device over
     * @param enc           Encrypted data. 256, 384 or 512 bytes long
     * @param label         Optional label to be associated with the message
     * @param mgf1Algorithm The hash algorithm to use for MGF1. Can be one of {{@link Algorithm.RSA_MGF1_SHA1}}, {{@link Algorithm.RSA_MGF1_SHA256}},
     *                      {{@link Algorithm.RSA_MGF1_SHA384}},{{@link Algorithm.RSA_MGF1_SHA512}}
     * @param hashAlgorithm The hash algorithm to use for hashing the label. Can be one of {{@link Algorithm.RSA_OAEP_SHA1}}, {
     *                      {@link Algorithm.RSA_OAEP_SHA256}},
     *                      {{@link Algorithm.RSA_OAEP_SHA384}},{{@link Algorithm.RSA_OAEP_SHA512}}
     * @return The decrypted data
     * @throws NoSuchAlgorithmException           If the encryption/decryption fails
     * @throws YHDeviceException                  If the device returns an error
     * @throws YHInvalidResponseException         If the response from the device cannot be parsed
     * @throws YHConnectionException              If the connection to the device fails
     * @throws InvalidKeyException                If the encryption/decryption fails
     * @throws YHAuthenticationException          If the session authentication fails
     * @throws NoSuchPaddingException             If the encryption/decryption fails
     * @throws InvalidAlgorithmParameterException If the encryption/decryption fails
     * @throws BadPaddingException                If the encryption/decryption fails
     * @throws IllegalBlockSizeException          If the encryption/decryption fails
     * @throws UnsupportedAlgorithmException      If the MGF1 algorithm is not one of {{@link Algorithm.RSA_MGF1_SHA1}}, {{@link Algorithm.RSA_MGF1_SHA256}},
     *                                            {{@link Algorithm.RSA_MGF1_SHA384}},{{@link Algorithm.RSA_MGF1_SHA512}} or if the hash algorithm is not
     *                                            one of {{@link Algorithm.RSA_OAEP_SHA1}}, {
     *                                            {@link Algorithm.RSA_OAEP_SHA256}},
     *                                            {{@link Algorithm.RSA_OAEP_SHA384}},{{@link Algorithm.RSA_OAEP_SHA512}}
     */
    public byte[] decryptOaep(final YHSession session, final byte[] enc, final String label, final Algorithm mgf1Algorithm,
                              final Algorithm hashAlgorithm)
            throws NoSuchPaddingException, NoSuchAlgorithmException, YHConnectionException, InvalidKeyException, YHDeviceException,
                   InvalidAlgorithmParameterException, YHAuthenticationException, YHInvalidResponseException, BadPaddingException,
                   IllegalBlockSizeException, UnsupportedAlgorithmException {
        if (!getAlgorithm().isRsaAlgorithm()) {
            throw new UnsupportedOperationException("This operation is only available for RSA keys");
        }
        if (enc == null) {
            return new byte[0];
        }
        if (!isOaepHashAlgorithm(hashAlgorithm)) {
            throw new UnsupportedAlgorithmException(hashAlgorithm.toString());
        }
        if (!isMgf1Algorithm(mgf1Algorithm)) {
            throw new UnsupportedAlgorithmException(mgf1Algorithm.toString());
        }

        if (enc.length != getBlockSize(getAlgorithm())) {
            throw new InvalidParameterException("Length of encrypted data must be 256, 384 or 512");
        }

        byte[] hashedLabel = getHashedData(getLabel(label).getBytes(), hashAlgorithm);


        ByteBuffer bb = ByteBuffer.allocate(3 + enc.length + hashedLabel.length); // 2 + 1 + enc.length + hashedLabel.length
        bb.putShort(getId());
        bb.put(mgf1Algorithm.getAlgorithmId());
        bb.put(enc);
        bb.put(hashedLabel);

        byte[] dec = session.sendSecureCmd(Command.DECRYPT_OAEP, bb.array());
        logger.info("Decrypted data with key 0x" + Integer.toHexString(getId()) + " and returned " + dec.length + " bytes");
        return dec;

    }

    // ------------- Help methods ---------------------------------------

    /**
     * @return The data block size
     */
    private static int getBlockSize(final Algorithm algorithm) {
        if (algorithm.equals(Algorithm.RSA_2048)) {
            return 256;
        } else if (algorithm.equals(Algorithm.RSA_3072)) {
            return 384;
        } else if (algorithm.equals(Algorithm.RSA_4096)) {
            return 512;
        } else {
            throw new InvalidParameterException("Unsupported RSA Algorithm: " + algorithm.toString());
        }
    }

    /**
     * @return The length of the hash data should be when signing using PSS RSA
     */
    private int getHashLength(final Algorithm algorithm) {
        if (algorithm.equals(Algorithm.RSA_MGF1_SHA1) || algorithm.equals(Algorithm.RSA_OAEP_SHA1)) {
            return 20;
        }
        if (algorithm.equals(Algorithm.RSA_MGF1_SHA256) || algorithm.equals(Algorithm.RSA_OAEP_SHA256)) {
            return 32;
        }
        if (algorithm.equals(Algorithm.RSA_MGF1_SHA384) || algorithm.equals(Algorithm.RSA_OAEP_SHA384)) {
            return 48;
        }
        if (algorithm.equals(Algorithm.RSA_MGF1_SHA512) || algorithm.equals(Algorithm.RSA_OAEP_SHA512)) {
            return 64;
        }
        throw new InvalidParameterException("Unsupported hash algorithm to use for MGF1");
    }

    private boolean isOaepHashAlgorithm(final Algorithm algorithm) {
        if (algorithm.equals(Algorithm.RSA_OAEP_SHA1) || algorithm.equals(Algorithm.RSA_OAEP_SHA256) || algorithm.equals(Algorithm.RSA_OAEP_SHA384) ||
            algorithm.equals(Algorithm.RSA_OAEP_SHA512)) {
            return true;
        }
        return false;
    }

    private boolean isPkcs1HashAlgorithm(final Algorithm algorithm) {
        if (algorithm.equals(Algorithm.RSA_PKCS1_SHA1) || algorithm.equals(Algorithm.RSA_PKCS1_SHA256) ||
            algorithm.equals(Algorithm.RSA_PKCS1_SHA384) || algorithm.equals(Algorithm.RSA_PKCS1_SHA512)) {
            return true;
        }
        return false;
    }

    private boolean isMgf1Algorithm(final Algorithm algorithm) {
        if (algorithm.equals(Algorithm.RSA_MGF1_SHA1) || algorithm.equals(Algorithm.RSA_MGF1_SHA256) || algorithm.equals(Algorithm.RSA_MGF1_SHA384) ||
            algorithm.equals(Algorithm.RSA_MGF1_SHA512)) {
            return true;
        }
        return false;
    }

}
